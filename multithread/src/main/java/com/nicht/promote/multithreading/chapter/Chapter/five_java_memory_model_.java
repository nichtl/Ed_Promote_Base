package com.nicht.promote.multithreading.chapter.Chapter;

/**
 * @Author Nicht
 * @Description  Java 内存模型
 * @Time 2021/4/22
 * @Link http://ifeve.com/java-memory-model-6/
 */
public class five_java_memory_model_ {
    public static void main(String[] args) {

    }
    /**
     * Java内存模型规范了Java虚拟机与计算机内存是如何协同工作的。Java虚拟机是一个完整的计算机的一个模型，因此这个模型自然也包含一个内存模型——又称为Java内存模型。
     * 如果你想设计表现良好的并发程序，理解Java内存模型是非常重要的。Java内存模型规定了如何和何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量。
     * 原始的Java内存模型存在一些不足，因此Java内存模型在Java1.5时被重新修订。这个版本的Java内存模型在Java8中仍在使用。
     * Java内存模型内部原理
     * Java内存模型把Java虚拟机内部划分为线程栈和堆。这张图演示了Java内存模型的逻辑视图. 本链接的 内存模型不够完整 参考
     * 栈和本地变量存放在线程栈上，对象存放在堆上
     * 一个本地变量可能是原始类型, 在这种情况下,他总是呆在线程栈上
     * 当然一个本地变量也可能指向的是一个对象的一个引用.这种情况下,引用即这个对象的内存地址是线程栈上
     * 但是这个对象本身是在堆中的 一个对象可能包含方法，这些方法可能包含本地变量。这些本地变量任然存放在线程栈上，即使这些方法所属的对象存放在堆上
     * 一个对象的成员变量可能随着这个对象自身存放在堆上。不管这个成员变量是原始类型还是引用类型。
     *  静态成员变量跟随着类定义一起也存放在堆上,即使这个对象中有原始类型的变量 也是跟随对象存在堆中的。
     *  硬件内存模型架构
     *  现代硬件内存模型与Java内存模型有一些不同,理解内存模式架构以及Java内存模型如何与
     *  它进行协同工作是非常重要的.这部分描述了通用的硬件内存架构,下面的部分将会描述Java内存是如何与它联手工作
     *  现代计算机的CPU通常有两个或者多个,从这一点可以看出，在一个有两个或者多个CPU的现代计算机上同时运行多个线程是可能的。
     *  每个CPU在某一时刻运行一个线程是没有问题的。这意味着，如果你的Java程序是多线程的，在你的Java程序中每个CPU上一个线程可能同时（并行）执行。
     *  每个CPU都包含一系列的寄存器，它们是CPU内内存的基础。CPU在寄存器上执行操作的速度远大于在主存上执行的速度。这是因为CPU访问寄存器的速度远大于主存。
     *  每个CPU可能还有一个CPU缓存层。实际上，绝大多数的现代CPU都有一定大小的缓存层。CPU访问缓存层的速度快于访问主存的速度，但通常比访问内部寄存器的速度还要慢一点。
     *  一些CPU还有多层缓存，但这些对理解Java内存模型如何和内存交互不是那么重要。只要知道CPU中可以有一个缓存层就可以了。
     *  一个计算机还包含一个主存。所有的CPU都可以访问主存。主存通常比CPU中的缓存大得多。
     *  通常情况下，当一个CPU需要读取主存时，它会将主存的部分读到CPU缓存中。它甚至可能将缓存中的部分内容读到它的内部寄存器中，然后在寄存器中执行操作。当CPU需要将结果写回到主存中去时，它会将内部寄存器的值刷新到缓存中，然后在某个时间点将值刷新回主存。
     *  当CPU需要在缓存层存放一些东西的时候，存放在缓存中的内容通常会被刷新回主存。CPU缓存可以在某一时刻将数据局部写到它的内存中，和在某一时刻局部刷新它的内存。它不会再某一时刻读/写整个缓存。通常，在一个被称作“cache lines”的更小的内存块中缓存被更新。一个或者多个缓存行可能被读到缓存，一个或者多个缓存行可能再被刷新回主存。
     *  上面已经提到，Java内存模型与硬件内存架构之间存在差异。硬件内存架构没有区分线程栈和堆。对于硬件，所有的线程栈和堆都分布在主内中。部分线程栈和堆可能有时候会出现在CPU缓存中和CPU内部的寄存器中。如下图所示：
     *  当对象和变量被存放在计算机中各种不同的内存区域中时，就可能会出现一些具体的问题。主要包括如下两个方面：
     *  -线程对共享变量修改的可见性
     *  -当读，写和检查共享变量时出现race conditions
     *  下面我们专门来解释以下这两个问题。
     *  共享对象可见性
     *  如果两个或者更多的线程在没有正确的使用volatile声明或者同步的情况下共享一个对象，
     *  一个线程更新这个共享对象可能对其它线程来说是不可见的。
     *  想象一下，共享对象被初始化在主存中。跑在CPU上的一个线程将这个共享对象读到CPU缓存中。
     *  然后修改了这个对象。只要CPU缓存没有被刷新会主存，对象修改后的版本对跑在其它CPU上的线程都是不可见的。
     *  这种方式可能导致每个线程拥有这个共享对象的私有拷贝，每个拷贝停留在不同的CPU缓存中。
     *  这就是多线程不可见性
     *  解决变量的不可见性可以使用volatile关键字,
     *  volatile 只能保证每次读取都是从主存中取的，并不能保证是最新的。每个线程从主存取值，修改，写回不是原子性的。
     *  T1取值，T1加一，T2取值，T1写回，T2加一，T2写回。最后还是只加一。
     *  要解决同步问题还是得上锁，或者同步代码。单个的volatile并不能保证同步。
     *  volatile关键字可以保证直接从内存中读取一个变量,如果这个变量被修改后总是
     *  会被写入回主存中去,而不是先将变量缓存到cpu缓存区再进行读写操作 ,
     *  也就是一个多线程情况下一个共享资源在对其进行写操作时敏感的情况下,将这个资源留在主存中保证其可见性
     *  Race Conditions  (竞态条件)
     *  如果两个或者更多的线程共享一个对象，多个线程在这个共享对象上更新变量，就有可能发生race conditions。
     *  想象一下，如果线程A读一个共享对象的变量count到它的CPU缓存中。再想象一下，线程B也做了同样的事情，但是往一个不同的CPU缓存中。现在线程A将count加1，线程B也做了同样的事情。现在count已经被增在了两个，每个CPU缓存中一次。
     *  如果这些增加操作被顺序的执行，变量count应该被增加两次，然后原值+2被写回到主存中去。
     *  然而，两次增加都是在没有适当的同步下并发执行的。无论是线程A还是线程B将count修改后的版本写回到主存中取，修改后的值仅会被原值大1，尽管增加了两次。
     *  解决这个问题可以使用Java同步块(@Link http://tutorials.jenkov.com/java-concurrency/synchronized.html )。
     *  一个同步块可以保证在同一时刻仅有一个线程可以进入代码的临界区。同步块还可以保证代码块中所有被访问的变量将会从主存中读入，
     *  当线程退出同步代码块时，所有被更新的变量都会被刷新回主存中去，不管这个变量是否被声明为volatile。
     *
     *
     * */


}
