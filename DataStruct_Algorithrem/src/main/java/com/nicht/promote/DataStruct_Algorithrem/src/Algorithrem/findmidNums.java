package com.nicht.promote.DataStruct_Algorithrem.src.Algorithrem;

import cn.hutool.core.util.StrUtil;
import com.alibaba.fastjson.JSON;

import java.util.*;

/**
 * @Author Nicht
 * @Description
 * @Time 2021/5/12
 * @Link 两个正序数组中位数
 */
public class findmidNums {

    /**
    * 两个正序数组
    * A     | 6 7  8  9         5
    * B     1 2 3  4  5 |
    * */
   // 思路一  直接合并AB数组求
    public static void main(String[] args) {
        String ps171632 ="{\"sysCode\":\"EVENT\",\"custId\":{custId},\"mrmId\":\"\",\"psId\":\"171632\",\"pId\":\"200\",\"idCard\":\"\"}";

        String ps171635 = "{\"sysCode\":\"EVENT\",\"custId\":{custId},\"mrmId\":\"\",\"psId\":\"171635\",\"pId\":\"200\",\"idCard\":\"\"}";



        List<Integer> custIds = Arrays.asList(6495317,9127103,13813121,95953842,78714772,60771226,12650638,6080491,49666511,24332770,8708057,2000316,56049075,8509163,49961263,482906,64964379,12762873,50812537,66976232,40730930,3295641,9272921,50619599,805143,91136016,35215334,95447104,4920167,14482502,45721096,2205238,1526495,4248732,96066342,1261112,8652148,51440236,1600069,43769912,79789142,4151772,6546273,53222225,88898730,55153730,51580296,2411258,10125568,65948054,63140297,98345700,97223118,1291068,9856533,66346815,51971841,9050303,2077686,25606952,2648017,54339858,43388097,97686478,49922192,5388013,211892,68401514,46099021,95929826,97633360,71870568,6013492,7324167,51936866,9856057,25960069,59410600,67748329,3086158,97877845,25533955,2112449,35311109,56661001,1297746,97868681,11012503,7683316,6131207,41465544,11155967,4898383,42244708,74375080,62892991,436881,7518273,7996712,88295770,39877461,95007330,8369468,572961,2328592,7336891,514447,31981334,72426897,2534669,71180242,54465479,10810017,92462886,57418869,43479060,1225334,4701268,67443907,80486442,2876881,8881411,2933671,4404025,4844282,83103603,94788094,63641599,97255280,1351180,70297062,23145132,5491173,83820802,61181348,11366222,5385308,30731738,7377608,81172654,53266558,92532791,1945973,78845346,72408932,65217224,65329061,54513914,3873630,3593977,74027419,9693909,90157235,2955433,72831522,51599964,4503191,59956966,96197568,5069114,30857350,98823132,9283961,1965031,7483279,4472081,6696238,96395778,300595,6608523,91561186,90224712,90944780,95368518,78081135,8347498,82279960,97527719,13180768,1916732,71814374,2324029,18020838,9741049,723371,13927141,1093321,48840815,60111091,385016,13929419,1452187,60095172,5669290,68950799,2737078,27399812,45984166,51129674,51129674,581114,823936,6080843,883121,98737161,1553585,37266706,78797079,9019967,61058114,98815034,432723,17105667,503750,55039250,65574862,98475086,96955583,4658831,10662020,8898070,75737861,578660,3095227,1387158,59852087,26441074,79473126,3199704,97321507,80280435,81420134,7295449,2840582,55009844,975365,50627654,2756598,54190385,53684825,2280416,363532,62083769,13952751,81105062,2637142,54056534,966121,17605309,10332689,6637218,1882848,590335,8189114,88291998,4274477,7628565,3521632,3756561,89845972,5990670,3249413,64932300,28137524,6905002,7382299,9494012,29201250,3850077,4795888,2961635,9369831,58351457,2250369,97885856,5970575,94469085,82545088,40593535,10126814,2519258,4732054,9945016,8502944,2115241,48461402,7754005,2600470,1261455,4136664,48842975,64766041,1278175,83909799,66626474,2491173,4726634,47714178,27496088,5830833,2165204,1962883,577486,45862389,1863315,9220162,1295844,98769342,78684123,27131410,1336000,414118,93410782,1738043,6632581,2301785,11065391,2856634,2123826,92008465,55436586,5396901,7816060,970814,83735824,17063951,16864354,59577474,56624778,98297989,1113574,5150217,98292218,2317186,4040553,94882649,1253537,8422706,44379820,17505735,9691695,3116146,6578544,14860188,39384978,46419355,9156667,4126169,4759966,926130,5222050,2048580,3049794,71406749,36684681,43394183,27196526,1104561,76430469,61596257,47236163,94256804,79758724,94656253,97864754,2990738,2545136,15853001,98212460,53724674,83549139,32287359,98814681,71453784,98075901,98271811,49002242,1131229,6361971,55406237,9937039,39231179,87844931,1077770,71910026,7044576,75714372,85819912,5201057,81717611,1934936,1524835,97428884,65561227,4749160,77399810,2568192,65558994,8407122,67241302,97219058,48699273,71256198,8724519,3779164,27367883,56657824,26714814,8324260,65441483,8855181,64269635,97798190,52371983,42327678,59720930,2174262,88831375,2804149,70361422,6145196,7359362,59939748,1009963,4468148,15522787,7359362);

        List<String> batchParam = new ArrayList<>();

        for (Integer custId : custIds){
            Map<String,Object> param = new HashMap<>();
            param.put("custId",custId);
            //batchParam.add(StrUtil.format(ps171635,param));
            batchParam.add(StrUtil.format(ps171632,param));
        }
        
        System.out.println( batchParam.toString() );

    }


    // 思路一  直接合并AB数组求 O(m+n)
    public static   Double method1 (int[] A ,int[] B){
        int alen  =  A.length;
        int blen  =  B.length;
        int [] temp =  new int[alen+blen];
        int count=0,ai=0,bj=0;
        if(alen == 0){
            return  (blen%2)==0?(B[(blen/2)-1]+B[blen/2])/2.0 : B[blen/2] ;
        }
        if(blen == 0){
            return  (alen%2)==0?(A[(alen/2)-1]+A[alen/2])/2.0 : A[alen/2] ;
        }
        while(true){
            if(ai==alen){
                while(bj!=blen){
                    temp[count++] = B[bj++];
                }
                break;
            }

            if(bj == blen){
                while(ai!=alen){
                    temp[count++] = A[ai++];
                }
                break;
            }
            if(A[ai]<B[bj]) {
             temp[count++] =  A[ai++] ;
            }else {
                temp[count++] = B[bj++];
            }
        }
        return   (count%2) == 0 ? (temp[(count/2)-1]+temp[count/2])/2.0 : temp[count/2];
    }
    // 思路二  二分查找法 O(log(m+n))
    public static  double method2(int[] nums1, int[] nums2){
     if(nums1.length>nums2.length){   //使得 nums1 成为最短的数组
         int [] temp = nums1;
         nums1=nums2;
         nums2=temp;
     }
     int  m = nums1.length;
     int  n = nums2.length;
     int  totalleft =  (m+n+1)/2;  //分割线左边元素需要满足的个数
     int  left=0, right=m;
     // 定义两个变量来表示左边 元素的个数和右边元素的个数
     /* 在最短数组上 寻找中位分割线 使得分割线满足
      *1.这条分割线需满足一下条件
      *2.分割线左侧的,最小数中的最大数小于右侧最大数中的最小数
      *3.分割线左边元素需要满足(m+n+1)/2个数的要求
      *4.在数组nums1[0,m]区间上寻找分割线
      * */
        // 2 3 4 6 8 9 10 12 18 20
        //由于是数组下标  可以直接得到 i 之前的元素个数
        /*  left = 0   right = 4    //  i=0+4-0/2 =2  i=2   j
        * [3,8|,9,10]
        * [2,4,6|,12,18,20]
        *  3 8  | 9 10  分割线  i =2
        * 2 4 6 | 12 18 20  分割线   j= 3
        * */
        //在nums1 上不断缩小找寻分隔线的位置
        while(left<right){  //条件一::一直找到左边元素个数大于等于右边元素个数
            System.out.println("left "+left +"right : "+right);
           int   i = left +(right-left)/2; //求中位数的index
            /** 取[LEFT,RIGHT]区间中间位置下标开始检测目标元素二分查找的过程是不断缩小的*/
            /**
             * 我们知道 这条分隔线左侧元素个数为 (m+n+1)/2
             * i+j= (m+n+1)/2
             * 根据 nums1的i的下标可以知道nums1左侧元素个数
             * 既可以知道 nums2 的个数为    (m+n+1)/2- i
             * totalleft -i
             * */
           int   j = totalleft -i ;
           //找 nums1 中分割线左边界最大数的index
           if(nums1[i-1]>nums2[j]){
          // 如果  nums1 此刻中位数的左边最大值大于nums右边最小值说明  在nums1中 中位线的位置在当前分割线的  左侧
          // 让右边界 舍去当前中位线位置的右区间   搜索区间变为[left , i-1];
               right  =  i-1;
           }else{
               //搜索区间变为[i,right];
               // 注意当[i,right] 区间上只有两个数的时候 left +(right-left)/2 永远会向下取整 == i了 那么就会进入死循环
               // left +(right-left)/2 改为 left +(right-left+1)/2 让偶数数组向上取整
               // 下一轮循环会永远死循环
               left  =  i ;
           }
        }
        int  i  = left;
        int  j  = totalleft - i;

        /*
        *     * A     | 6 7  8  9    避免下边越界
         *    *B    1 2 3  4  5 |
         *
         *  A     1 2 3  4  5 |    避免下边越界
         * B  | 6 7  8  9 10 11
        *
        * */
        int  nums1LeftMax = i==0?Integer.MIN_VALUE  : nums1[i-1];
        int  nums1RightMin = i==m?Integer.MAX_VALUE  : nums1[i];
        int  nums2LeftMax = j==0?Integer.MIN_VALUE : nums2[j-1];
        int  nums2RightMin= j==n? Integer.MAX_VALUE : nums2[j];
        if(((m+n)%2)==0){
            return Math.max(nums1LeftMax,nums2LeftMax);
        }else{
            return (Math.max(nums1LeftMax,nums2LeftMax)+Math.max(nums1RightMin,nums2RightMin))/2.0;
        }

    }

    public static  double method3(int[] A, int[] B){
        if(A.length < B.length){
            return   method3(B,A);
        }
        int  alen  = A.length;
        int  blen  = B.length;
        int  totalleft =  (alen+blen+1)/2;
        int  aleft=0,aright=alen;
        while (aleft<aright){
            int ai   = aleft+(aright-aleft+1)/2;
            int bj   = totalleft-aleft;
            if(A[ai -1]>B[bj]){
                aright = ai-1;
            }else{
                aleft  = ai;
            }
        }

        return  1.0;
    }

    public  static boolean isNumber(String s) {
          int n =1;

        return  s.replaceAll("\\\\s*[+-]?((\\\\d*\\\\.?\\\\d+)|(\\\\d+\\\\.?))([eE][+-]?\\\\d+)?\\\\s*","").length()==0;
    }
    //00000000000000000000000000001011
    public static int hammingWeight(int n) {
        String  s  = n+"";
        String  b = s.replaceAll("1","");
        return  s.length() -  b.length();
    }


















}
